# Tab-Isolated Token Protocol (TITP): Post-Injection XSS Mitigation

## Authors
- Harsh Singhal (Amazon.com Services LLC)

## Participate
- [GitHub Repository](https://github.com/harsh0/xss-mitigation-explainer) (xss-mitigation-explainer)
- [Issues](https://github.com/harsh0/xss-mitigation-explainer/issues) (placeholder)

## Table of Contents
- [Introduction](#introduction)
- [Goals](#goals)
- [Non-goals](#non-goals)
- [Use Cases](#use-cases)
- [Proposed Solution](#proposed-solution)
- [Key Scenarios](#key-scenarios)
- [Detailed Design Discussion](#detailed-design-discussion)
- [Considered Alternatives](#considered-alternatives)
- [Stakeholder Feedback](#stakeholder-feedback)
- [References & Acknowledgements](#references--acknowledgements)

## Introduction

Cross-Site Scripting (XSS) attacks remain a persistent threat to web security. While existing defenses like Content Security Policy (CSP) and input sanitization focus on prevention, there is currently **no reliable mechanism for backend systems to distinguish between legitimate application requests and those generated by malicious scripts after a successful XSS injection**.

This is particularly problematic for applications with long-lived sessions (e-commerce, streaming services, social media) where the impact of successful XSS can be severe and prolonged.

### The Problem

Once an XSS script executes in a browser tab, all HTTP requests appear identical to the backend server, regardless of whether they originate from legitimate application code or injected malicious scripts. This creates a fundamental blind spot in web security.

## Goals

- Enable backend servers to distinguish between legitimate and malicious requests after XSS injection
- Provide real-time XSS mitigation capabilities for applications with long-lived sessions
- Create a standardized defense mechanism comparable to CSRF tokens but for XSS
- Minimize implementation overhead for existing applications
- Maintain compatibility with current authentication and security models

## Non-goals

- Replace existing XSS prevention mechanisms (CSP, input sanitization)
- Provide protection against all forms of XSS (this is a post-injection mitigation)
- Address XSS in applications that re-authenticate on every session
- Solve client-side XSS detection problems

## Use Cases

### Primary Use Case: E-commerce Platform Protection
An e-commerce site with persistent login sessions needs to prevent malicious scripts from making unauthorized purchases or account modifications after successful XSS injection.

### Secondary Use Cases
- **Social Media Platforms**: Prevent unauthorized posts, friend requests, or data access
- **Banking Applications**: Block fraudulent transactions initiated by XSS scripts
- **Content Management Systems**: Prevent unauthorized content modifications
- **SaaS Applications**: Protect against data exfiltration and unauthorized operations

## Proposed Solution

The Tab-Isolated Token Protocol (TITP) introduces two key components:

### 1. `TabOnly` Cookie Attribute
A new cookie attribute that creates tab-specific, HttpOnly cookies with these properties:
- Accessible only within the originating browser tab
- Automatically destroyed on tab close/refresh
- Cannot be accessed by JavaScript (HttpOnly)
- Transmitted only over secure connections (Secure)

### 2. Cryptographic Token Pairing System
A client-server cryptographic system that:
- Client generates ephemeral public-private key pair per tab
- Server encrypts tokens with client's public key
- Only legitimate client can decrypt tokens using private key
- Server validates decrypted token-cookie pairs for each request

## Key Scenarios

### Scenario 1: Normal Operation
```
1. User loads application page
2. JavaScript generates ephemeral key pair using Web Crypto API
3. JavaScript makes initial secure call with public key
4. Backend generates TabOnly cookie + encrypts token with public key
5. Client decrypts token using private key (stored in closure)
6. Future API requests include decrypted token in headers
7. Backend validates token against TabOnly cookie
8. Legitimate requests proceed normally
```

### Scenario 2: XSS Attack After Token Issuance (Legitimate App Wins Race)
```
1. Legitimate app generates key pair and receives encrypted token successfully
2. XSS script executes and generates its own key pair
3. XSS script attempts to call token API
4. Backend detects existing TabOnly cookie (already used)
5. XSS token request rejected - legitimate app already has the token
6. Malicious API requests fail validation (XSS has no valid token)
```

### Scenario 3: XSS Attack Before Token Issuance (XSS Wins Race)
```
1. XSS script executes immediately and generates its own key pair
2. XSS script calls token API first and receives encrypted token
3. Legitimate app attempts to get token
4. Backend detects TabOnly cookie already exists
5. Legitimate app request rejected
6. App triggers page refresh, clearing XSS and resetting state
7. Fresh page load allows legitimate app to get token first
```

### Scenario 4: XSS Fetch Sniffing Attack (Token Interception Fails)
```
1. Legitimate app generates key pair and receives encrypted token
2. XSS script executes and overwrites fetch() to intercept requests
3. XSS script captures encrypted token from legitimate app's API calls
4. XSS script attempts to use stolen encrypted token in malicious requests
5. XSS cannot decrypt token (generated with different key pair)
6. Malicious requests fail - backend receives invalid/undecryptable token
7. Only legitimate app can decrypt and use its token successfully
```

**Note**: Scenarios 2-3 show race conditions (who gets token first), while Scenario 4 shows fetch interception attacks. The cryptographic protection ensures stolen encrypted tokens are useless without the corresponding private key.

## Detailed Design Discussion

### Cookie Specification
```
Set-Cookie: tab_id=abc123; HttpOnly; Secure; SameSite=Strict; TabOnly
```

The `TabOnly` attribute would be implemented by browsers to:
- Isolate cookie storage per browser tab
- Prevent cross-tab cookie sharing
- Automatically cleanup on tab destruction

### Token Generation Algorithm
```javascript
// Client-side: Generate key pair and request token
async function requestTabToken() {
  if (!browserSupportsTabOnly()) {
    // Fall back to existing security measures
    useTraditionalCSRF();
    return;
  }
  // Generate ephemeral key pair
  const keyPair = await crypto.subtle.generateKey(
    { name: "RSA-OAEP", modulusLength: 2048, publicExponent: new Uint8Array([1, 0, 1]), hash: "SHA-256" },
    true,
    ["encrypt", "decrypt"]
  );
  
  // Export public key
  const publicKey = await crypto.subtle.exportKey("spki", keyPair.publicKey);
  
  // Request encrypted token
  const response = await fetch('/api/token', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ publicKey: Array.from(new Uint8Array(publicKey)) })
  });
  
  const { encryptedToken } = await response.json();
  
  // Decrypt token using private key
  const decryptedToken = await crypto.subtle.decrypt(
    "RSA-OAEP",
    keyPair.privateKey,
    new Uint8Array(encryptedToken)
  );
  
  return new TextDecoder().decode(decryptedToken);
}

// Server-side pseudocode
function generateTabToken(request) {
  const { publicKey } = request.body;
  const tabCookie = request.cookies.tab_id;
  
  if (tabCookie && isTokenIssued(tabCookie)) {
    throw new Error('Token already issued for this tab');
  }
  
  const tabId = tabCookie || generateUniqueId();
  const token = generateSecureToken(tabId);
  
  // Encrypt token with client's public key
  const encryptedToken = encrypt(token, publicKey);
  
  setTabOnlyCookie(response, tabId);
  
  return { encryptedToken };
}
```

### Request Validation
```javascript
// Server-side pseudocode
function validateRequest(request) {
  const tabCookie = request.cookies.tab_id;
  const token = request.headers['x-xss-token'];
  
  if (!tabCookie || !token) {
    return false;
  }
  
  return validateTokenForTab(token, tabCookie);
}
```

### Browser Implementation Requirements

Browsers would need to implement:
- Tab-specific cookie storage mechanisms
- Automatic cleanup on tab close/refresh
- Isolation between tabs for `TabOnly` cookies

## Considered Alternatives

### Alternative 1: SessionStorage (Tab-specific)
**Rejected**: JavaScript-accessible storage provides no protection against XSS scripts.

### Alternative 2: Timestamp-Based Tab Isolation
**Rejected**: Uses `performance.timeOrigin` as a tab identifier with regular HttpOnly cookies, avoiding the need for new browser primitives, but creates exploitable vulnerabilities.

**Approach**: Client sends `performance.timeOrigin` value along with public key in the initial API call. Server sets an HttpOnly cookie using the timestamp as the cookie name (e.g., `Set-Cookie: XSS_1641234567890=abc123; HttpOnly; Secure`) and returns the encrypted token. The timestamp serves as a unique tab identifier since practically no two tabs of the same website can have identical `performance.timeOrigin` values in the same browser.

**Critical Vulnerability**: XSS attackers can bypass this system by sending fabricated timestamp values in API calls, making the server believe each fake timestamp represents a different legitimate tab. This allows unlimited token generation within a single browser tab.

**Problems:**
- **Tab Identity Forgery**: XSS scripts can generate fake `performance.timeOrigin` values
- **No Browser Enforcement**: Regular cookies don't provide true tab isolation
- **Unlimited Token Generation**: Attackers can create infinite "virtual tabs" to bypass restrictions
- **Same Attack Surface**: Provides no additional security over traditional approaches

### Alternative 3: Browser Extension-based Solutions
**Rejected**: Limited deployment scope and requires user installation.

### Alternative 4: Relaxed Token Reissuance
**Rejected**: Creates race conditions and potential DoS vectors through token exhaustion.

## Security Considerations

### Threat Model
- **Attacker Capability**: Successful XSS injection with arbitrary JavaScript execution, including ability to generate cryptographic keys
- **Protection Scope**: Backend request validation and origin verification
- **Limitations**: 
  - Does not prevent initial XSS injection or client-side attacks
  - XSS scripts can mimic legitimate behavior (generate keys, call APIs)
  - **Goal**: Prevent even legitimate app developers (who have full knowledge of the token encryption system and backend APIs) from bypassing the security mechanism without proper browser-enforced tab context

### Security Boundaries

**What TITP Protects Against:**
- Token theft and reuse by XSS scripts
- Cross-tab token sharing
- Malicious developers bypassing their own security systems
- Request forgery without proper tab context

**What TITP Does NOT Protect Against:**
- XSS scripts that win the initial token race (but provides detection/recovery)
- Client-side DOM manipulation
- Social engineering attacks
- Server-side vulnerabilities

**Key Insight**: The protocol's strength is not in preventing all XSS behavior, but in ensuring that **only requests from the legitimate tab context with proper cryptographic proof are accepted by the backend**.

### Security Properties
- **Token Uniqueness**: At most one valid token per tab
- **Backend Verifiability**: Cryptographic token validation
- **Tab Isolation**: Tokens cannot be shared across tabs
- **Temporal Validity**: Tokens can include expiration
- **Cryptographic Protection**: Tokens encrypted with client-generated keys
- **XSS Resistance**: Malicious scripts cannot decrypt stolen encrypted tokens
- **Race Condition Awareness**: XSS scripts can generate keys and win token races, but legitimate apps can detect and recover

### Attack Resistance
- **Script Injection**: Malicious scripts cannot access `TabOnly` cookies or decrypt tokens from other key pairs
- **Token Theft**: Even if encrypted tokens are intercepted, they cannot be decrypted without the corresponding private key
- **Cross-tab Attacks**: Tab isolation prevents token sharing
- **Replay Attacks**: Tokens can include freshness requirements
- **Fetch Manipulation**: XSS scripts see only encrypted tokens, cannot forge valid requests
- **Key Generation Race**: XSS scripts can generate keys and win races, but legitimate apps can detect and recover via page refresh

## Implementation Considerations

### Deployment Strategy
1. **Progressive Enhancement**: Graceful degradation when `TabOnly` unsupported
2. **Framework Integration**: Support in React, Angular, Vue.js
3. **Middleware Development**: Server-side integration libraries

### Performance Impact
- **Minimal Overhead**: Single additional cookie and token validation
- **Scalable**: Stateless implementation possible with signed tokens
- **Caching**: Token validation can be optimized with caching

### Backward Compatibility
Applications can implement fallback mechanisms for browsers without `TabOnly` support, maintaining current security posture while gaining enhanced protection where available.

## Stakeholder Feedback

### Questions for Browser Vendors
1. Feasibility of implementing `TabOnly` cookie attribute
2. Performance implications of tab-specific cookie storage
3. Integration with existing cookie management systems

### Questions for Web Developers
1. Integration complexity with existing authentication systems
2. Framework-specific implementation preferences
3. Debugging and development tool requirements

### Questions for Security Community
1. Threat model completeness and edge cases
2. Cryptographic requirements for token generation
3. Standards compliance and specification needs

## References & Acknowledgements

- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [RFC 6265: HTTP State Management Mechanism](https://tools.ietf.org/html/rfc6265)
- [Content Security Policy Level 3](https://www.w3.org/TR/CSP3/)
- [Web Application Security Working Group](https://www.w3.org/2011/webappsec/)

Special thanks to the Web Application Security Working Group for their ongoing work in web security standardization.
